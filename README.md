# teach-yourself-cs-curriculum

This document is my record of work towards a Self-Taught equivalent of a CS degree. I want to pursue mastery in my craft and the aim for this project that will most likely span years is to keep track and log of all things and be able to share it with people who could benefit form it. The core curriculum is as perscribed by Oz Nova and Myles Byrne, authors of [teachyourselfcs.com](https://teachyourselfcs.com), but consists of many additional resources that I have completed / am interested in. If you want to ask questions about the core curriculum, all the answers are to be found at the link above. The files in this repository are a collection of all the possible files, notes, etc. that I have been using for my work. It's a snapshot of a real-life workplace, with various papers and books scattered around than a repository of coherent code, and it should be treated as such. Use it to guess my process, look at resources I've worked on, etc.

The purpose of this repository is twofold - to keep myself organised and accountable, and also to be able to share my experience with other people who are undertaking a similar challenge of completing this curriculum.

Join my [Discord server](https://discord.gg/HjNfTnu9aQ) if you're interested in working through that curriculum too!

## Table of Contents

- [Progress](#progress)
- [General Findings](#general-findings)
- [Notes on different parts of the course](#course)
- [References](#references)

## Progress

Here's a list of all courses I'm planning to take. They're mostly taken from the [tycs](teachyourselfcs.com) website, which I'm treating as a central point of my curriculum, but I've been adding other resources as I was exploring varous avenues.

### Completed

- [x] (book) [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS), by [getify](https://github.com/getify) books 1-6. Absolutely an amazing piece of work on JS. Highly recommend.
- [x] (book) [C.O.D.E](https://en.wikipedia.org/wiki/Code:_The_Hidden_Language_of_Computer_Hardware_and_Software) by [Charles Petzold](https://www.charlespetzold.com/). Stunning book on the nature of computers, clear explanations, great storytelling.
- [x] (book/video course) [Learn C the Hard Way](https://shop.learncodethehardway.org) by [Zed Shaw](https://twitter.com/lzsthw). I've learned a lot about modern C programming from Zed, but more importantly, good habits. The learning methodology really stuck with me and pays dividends on all learning since. I highly recommend it even just for that reason.
- [x] (mooc + book) [Learning How To Learn](https://www.coursera.org/learn/learning-how-to-learn) and [A Mind for Numbers](https://barbaraoakley.com/books/a-mind-for-numbers/) by [Barbara Oakley](https://barbaraoakley.com/). Transforming course and a book. Understanding the neuroscience behind learning has helped me treat a lot of imposter syndrome and made my learning more efficient.
- [x] (book) [Effective C](https://nostarch.com/Effective_C). A thorough look at C - provided great commentary and supplimented a lot of knowledge in a very clear way. Recommend.
- [x] (book) [The C Programming Language](https://en.wikipedia.org/wiki/The_C_Programming_Language). Absolute classic, great peek into the 'past', but I found myself not being the target audience. Only used it correctly after Zed Shaw's resources and reading Effective C. Still a valuable read.
- [x] (book) [Good Math](https://www.amazon.com/Good-Math-Computation-Pragmatic-Programmers/dp/1937785335). I've been shying away from maths most of my life, and this book is one of the reasons I've turned around to the beauty of Mathematics.
- [x] (mooc) [Information Representation in Computer Systems](https://www.educative.io/courses/information-representation-computer-systems). Sounded great, but ended up being very superficial and kinda put together in a rush. One of many resources from educative that I tried and wasn't happy with. Their content is a hit or miss, still, the coding interview prep resources are quite decent, and I can see the resources quality grow over a few months since I started my subscription so don't write them off just yet.
- [x] (book) [Practical Algorithms](https://bradfieldcs.com/algos/)
- [x] (project) Game of Life implementation in Python
- [x] (book) [Beginning Ruby 3 from Beginner to Pro](https://www.apress.com/gp/book/9781484263235) Ruby was a in-and-out favourite language of mine and I am so happy to have revisited it. That book was a great help and came to be especially useful due to inclusion of an appendix that gives you a crash course in Ruby if you're not new to programming and a great library overview.
- [x] (book) [Practical SQL](https://www.amazon.com/Practical-SQL-Beginners-Guide-Storytelling/dp/1593278276)
- [x] (course)[Algoexpert - Systems Expert](https://www.algoexpert.io)

### Currently working on

- [ ] (course)[Algoexpert - AlgoExpert - 150 questions](https://www.algoexpert.io)

### Next in line

- (book) [Grokking Algorithms](https://www.manning.com/books/grokking-algorithms)
- [ ] (challenge) [advent of code (all years, up to challenge 5](https://adventofcode.com) I want to practice what I learn about Ruby and test out some of the language features, so I am intending to solve a bunch of challenges to explore the language's features.
- [ ] [Shotts, Linux Command Line](http://linuxcommand.org/tlcl.php)
- [ ] (book) [Practical Vim: Edit Text at the Speed of Thought](https://www.amazon.com/Practical-Vim-Edit-Speed-Thought/dp/1680501275/) I've been using `vim` for everything I do for a while now, and it's great, but I know there's so much more to discover.
- [ ] (book) [Composing Programs](https://composingprograms.com) Alternative to SICP as per the tycs guide, using Python as examples. I have attempted it early on in the process and didn't like it - the textbook itself is quite dry as it is intended to be used as a textbook alongside an actual course. If I can get access to good quality videos from the CS61A lectures I will probably finish it at a later date.
- [ ] (video) [CS 186 - DBMS](https://www.youtube.com/user/CS186Berkeley/playlists) This series of database lectures videos I have postponed working with, similarly as Composing Programs, it is intended to be used alongside the course, and that is something to solve for.
- [ ] (book) [Cracking the Coding Interview](https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850) Interviewing is a controversial topic, and this books is the holy grail of a _certain_ kind of interviewing methodology. I am intending to go through most of them, and although it focuses on Java and many challenges are deeply connected to Java and don't translate to _any_ language, studying bits of it, I found great use of the solutions and other explanations of the _attitude_ of solving those problems, moreso than the actual problems themselves, so I am planning to give it a go.
- [ ] (book) [Computer Systems, a Programmer's Perspective](http://csapp.cs.cmu.edu/3e/home.html) I've started reading it and it's a leviathan of a book - great in size, and quite dense, but nicely laid out. I'm yet to decide how to approach working with such a large text in a way that makes it most useful.
- [ ] (book) [Algorithm Design Manual](https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/?pldnSite=1)
- [ ] (videos) [Gynvael Coldwind's YT Channel, selected content](https://www.youtube.com/watch?v=MM4hDpzFUcA)
- [ ] [How to Solve It](https://www.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069111966X)
- [ ] [Discrete Mathematics, Lovasz](https://cims.nyu.edu/~regev/teaching/discrete_math_fall_2005/dmbook.pdf)
- [ ] [Operating Systems - Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/)
- [ ] [(only available in Polish) Zrozumiec Programowanie](https://ksiegarnia.pwn.pl/Zrozumiec-programowanie,688790689,p.html)
- [ ] [Computer Networking: A Top-Down Approach](https://www.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149)
- [ ] [Crafting Interpreters](https://craftinginterpreters.com/)
- [ ] [Designing Data-Intensive Applications](https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321)
- [ ] [100 LeetCode Questions](https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850)
- [ ] [Advent of Code - all challenges from years 2015-2020](https://adventofcode.com/)
- [ ] [Oh shit git](https://wizardzines.com/zines/oh-shit-git/)
- [ ] [tmux 2 - Productive Mouse-Free Development](https://pragprog.com/titles/bhtmux2/tmux-2/)
- [ ] [Introducing Python](https://www.amazon.com/Introducing-Python-Modern-Computing-Packages/dp/1492051365)
- [ ] [Python for Programmers (educative)](https://www.educative.io/path/python-for-programmers)
- [ ] [Python Data Analysis and Visualisation (educative)](https://www.educative.io/path/python-data-analysis)
- [ ] [Ace the Python Coding Interview (educative)](https://www.educative.io/path/ace-python-coding-interview)
- [ ] [Scalability & System Design for Developers (educative)](https://www.educative.io/path/scalability-system-design)
- [ ] [DevOps for Developers (educative)](https://www.educative.io/path/devops-for-developers)
- [ ] (book) [Annotated Turing](https://www.charlespetzold.com/books/) by [Charles Petzold](https://www.charlespetzold.com/)
- [ ] [Structure and Implementation of Computer Programs](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html)
- [ ] [Brian Harvey's Berkeley CS 61A](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter)
- [ ] [Berkeley CS 61C](https://teachyourselfcs.com/)
- [ ] [Steven Skiena's Lectures](https://teachyourselfcs.com/)
- [ ] [Mathematics for Computer Science](https://teachyourselfcs.com/)
- [ ] [Tom Leighton's MIT 6.042J](https://teachyourselfcs.com/)
- [ ] [Berkeley CS 162](https://teachyourselfcs.com/)
- [ ] [Stanford CS 144](https://teachyourselfcs.com/)
- [ ] [Readings in Database Systems](https://teachyourselfcs.com/)
- [ ] [Alex Aiken's course on Languages and Compilers](https://teachyourselfcs.com/)
- [ ] [MIT 6.824 Distributed Systems](https://teachyourselfcs.com/)
- [ ] [MIT Missing Semester](https://missing.csail.mit.edu/)
- [ ] [CS50](blank)
- [ ] [Mathematical Thinking in Computer Science](https://www.coursera.org/learn/what-is-a-proof/home/welcome)
- [ ] [One Lone Coder's Youtube Channel](https://www.youtube.com/channel/UC-yuWVUplUJZvieEligKBkA)
- [ ] [Coding Train]()

## General Findings

### Biggest Challenges

By far the most challenging part of taking a self-guided course like this is not doing it with other people. I have started a [Discord Server](https://discord.gg/HjNfTnu9aQ) for people who are also working through that curriculum, and it is helpful to exchange experiences and advice. Be ready for a lot of frustration trying to find solutions to your problems without a centralised place for people who are doing something similar hang out. Luckily there are groups centered around various resources and topics (SICP has a big community).

### First few weeks

Working through the first month of the curriculum has been a challenge - especially in guiding my learning and scheduling sessions. Working on your own you have to answer questions regarding what to study, for how long, and what are measurable deliverables. I've iterated over a few frameworks and I've found that having a clear view of a week ahead with a minimum goal works best for me. The study topics are organised in sections as per the teachyourselfcs curriculum, so for example:

I'm working through the Programming section, directly on Composing Programs, therefore every day I spend 3-5h on the main topic. To add variety, and for pleasure of it (I find it brings me the most joy to do) I also schedule daily code challenge sessions (leetcode / codewars / advent of code etc). That takes up a couple hours, and I use it to not only brush up on Algorithms, Data Structures, and Problem Solving, but also polish a language of my choice that I'm currently working with. As a tetriary topic of the day I include meta-study, on the tooling that I am using. [Therefore there's always a 30-60 minute session on vim / tmux / shell scripting etc.](#rethinking-development-process-and-tooling). Lastly, I make sure to review [recent knowledge.](#flashcards-flashcards-flashcards)

### Flashcards, flashcards, flashcards.

I'm using a [tool called Anki](https://apps.ankiweb.net/) to organise my knowledge into bite-sized reviewable flashcards. It's an incredible and simple tool that enabled me to actually retrieve a lot of knowledge. Simply as I read / watch / code, every time I stumble upon a nugget of information, I distill it to a fact, write it down into the flashcard database and review them daily. Time invested in those is worth its weight in gold for me.

### Rethinking development process and tooling

A few weeks in it became clear that counting on inspiration and good mood for learning is not enough, and so to ensure that I progress at a rate I'd like to, I had to put a few systems in place. As most of the challenges I'm facing are due to the nature of self-learning, most advice here is on how to stay motivated and engaged without outside stimuli and accountability.

- Rule of thumb: There is always something to learn. A few years ago at a startup I worked at, a colleague of mine said a phrase that went something like that: "I refuse to believe that there is nothing to do here". We were talking about a colleague of ours who quite frankly was straight down slacking for hours, but the context aside, the phrase stuck with me. The point discussed was the notion of feeling responsible and proud about the work being done. I found myself slacking for hours or sometimes days, purely due to a lack of sense of ownership of my learning. Formalizing my processes and holding myself accountable to a schedule and deliverables changed everything. To re-coin the phrase: "If you care about your work, I refuse to believe there was nothing you could do that day to move towards what you want to achieve."
- Every day, after I complete my work I do a very quick evaluation of what I think I achieved (often differs from what I've actually done) vs what I intended to do, and whether I feel proud of my efforts today. Learning is often so fuzzy and without specific boundaries, that it's easy to feel like you're under-achieving. Keeping myself in check with daily mini-retros and one at the end of every week fixes that problem.
- When facing a lot of new information and feeling discouraged about having trouble 'getting it', I learned to persevere and continue learning. Having learned about how brains process new information from [A Mind for Numbers](https://www.amazon.com/Mind-Numbers-Science-Flunked-Algebra-ebook/dp/B00G3L19ZU) I have developed a process of immersing myself in the topic nonetheless. To get more comfortable with a topic I can't fully understand I work through it from various angles, whether it be drawing things out on paper or whiteboard, trying to explain it to a friend, coding out my own solutions and implementations, etc. It feels weird and forced, but after a few days of focusing on the topic, whatever it could be, there is no way you won't start feeling familiar with it and the discomfort disappears. And with it, comes confidence and knowledge.

Working on the core Computer Science content is one thing, but becoming more proficient with the tooling while doing so is a completely different topic. I've been used to working in VSCode + separate terminal setup, but due to the fact that I am working on two different computers often (macos and linux), I need a reliable and replicable setup on both machines. For that reason I have narrowed the text editing and all work on a computer to using `tmux`, and `vim`. If you're not sure where to start with that, [I suggest a great series of video lectures](https://www.youtube.com/channel/UCuXy5tCgEninup9cGplbiFw).

One example of a simple gain is to use a tool like [nodemon](https://github.com/remy/nodemon) to speed up iteration through the coding challenges / exercises. Do not ignore it for just being a JS tool, take a look at the documentation and the `--exec` flag.

### Command Line tools i highly recommend

All should be supported under most unix systems.

- `fzf` for fuzzy matching searches in text files. a good alternative to grep/ripgrep for quick searches
- `broot` for a very neat alternative to `ls -R` or `tree` commands
- `nnn` a more advanced alt to `broot`
- `ranger` for navigating files with `vi` bindings
- `tldr` for snippets of usage examples of tools, saves you stackoverflow googling
- `pretzo` [for a really pretty](https://github.com/sorin-ionescu/prezto) `zsh` prompt.

### Course

Various notes from the course content, that I will probably want to look up later.

#### Programming

#### Composing Programs

I found [this article](https://accu.org/journals/overload/16/86/golodetz_1506/) useful while digesting Partition Trees described in section 2.3.6. Excerpt:

A partition tree is a way of representing a hierarchy of these partitions of an entity. The way it works is as follows:

- Each node in the tree represents a part of the whole entity. In particular, the root node of the tree represents the entity in its entirety.
- As is usual with trees in computer science, a node is either a branch node or a leaf node. (The distinction is that a branch node has child nodes, whereas a leaf has none.) In a partition tree, the children of a branch node represent a partition of the branch node (properly speaking, the parts of the entity represented by the children of the branch node represent a partition of the part of the entity represented by the branch node, but continually distinguishing between nodes and the sub-entities they represent is tedious).
- Each layer in the hierarchy represents a partition of the entire entity.

Using our pizza analogy, we could imagine first dividing our pizza into three portions, one for each person at the table. Each person's portion is then further sub-divided into four slices. Each person's slices are a partition of their portion, and the portions are a partition of the pizza as a whole. Furthermore, if you take all the slices, or all the portions, together, you have the entire pizza.

## References

This repository would not have existed if I had not been insipred by the people who did things like that before me. I'm eternally grateful for efforts of others publishing resources online, and here is a list of just a select few that I've used over the years to become a better programmer.

- [CS academy - algos resource + useful graph visualisation tool](https://csacademy.com/)
- [Coding Interview University](https://github.com/jwasham/coding-interview-university)
- [5+5](https://www.reddit.com/r/learnprogramming/comments/gsansp/my_55step_selftaught_cs_curriculum_updated/)
- [Project-Based Learning](https://github.com/tuvtran/project-based-learning)
- [Let's Build a Compiler](https://compilers.iecc.com/crenshaw/)
- [OSSU](https://github.com/ossu/computer-science)
- [p1xt](https://github.com/P1xt/p1xt-guides/blob/master/README.md)
- [startup next door](https://startupnextdoor.com/)
- [computer stuff they didn't teach you](https://www.youtube.com/shanselman)
